{{/*
Copyright 2019-present Facebook Inc. All rights reserved.
This source code is licensed under the Apache 2.0 license found
in the LICENSE file in the root directory of this source tree.
*/}}

{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "gql_edge" }}
{{ template "header" $ }}

import "context"

{{ range $n := filterNodes $.Nodes }}
	{{ $r := $n.Receiver }}
	{{ range $e := filterEdges $n.Edges }}
		{{ $names := nodePaginationNames $e.Type -}}
		{{- if $e.Unique }}
		func ({{ $r }} *{{ $n.Name }}) {{ $e.StructField }}(ctx context.Context) (*{{ $names.Node }}, error) {
			result, err := {{ $r }}.Edges.{{ $e.StructField }}OrErr()
			if IsNotLoaded(err) {
				result, err = {{ $r }}.Query{{ $e.StructField }}().Only(ctx)
			}
			return result, {{ if $e.Optional }}MaskNotFound(err){{ else }}err{{ end }}
		}
		{{- else if not $.Annotations.GQLSchemaGenerator }}
		func ({{ $r }} *{{ $n.Name }}) {{ $e.StructField }}(ctx context.Context) ([]*{{ $names.Node }}, error) {
			result, err := {{ $r }}.Edges.{{ $e.StructField }}OrErr()
			if IsNotLoaded(err) {
				result, err = {{ $r }}.Query{{ $e.StructField }}().All(ctx)
			}
			return result, err
		}
		{{- else if $e.Annotations.EntGQL.RelayConnection }}
			{{- if not $.Annotations.GQLSchemaGenerator.RelaySpec }}
				{{ fail "must enable relay specification via the WithRelaySpec option" }}
			{{- end }}
			{{- if not $e.Type.Annotations.EntGQL.RelayConnection }}
				{{ fail (printf "must enable Relay Connection via the entgql.RelayConnection annotation on the %s entity" $e.Type.Name) }}
			{{- end }}
		func ({{ $r }} *{{ $n.Name }}) {{ $e.StructField }}(
			ctx context.Context,
			orderBy *{{ $names.Order }},
			// where *{{ $names.WhereInput }},
			after *Cursor,
			before *Cursor,
			first *int,
			last *int,
		) (*{{ $names.Connection }}, error) {
			return {{ $r }}.Query{{ $e.StructField }}().
				Paginate(ctx, after, first, before, last,
					With{{ $names.Order }}(orderBy),
					// With{{ $names.Order }}Filter(where.Filter),
				)
		}
		{{- else }}
		func ({{ $r }} *{{ $n.Name }}) {{ $e.StructField }}(
			ctx context.Context,
			orderBy *{{ $names.Order }},
			// where *{{ $names.WhereInput }},
			page int,
			limit int,
		) ([]*{{ $names.Node }}, error) {
			return {{ $r }}.Query{{ $e.StructField }}().
				Limit(limit).Offset(page).
				Order(func(s *sql.Selector) {
					if orderBy != nil {
						c := s.C(orderBy.Field.field)
						if orderBy.Direction == OrderDirectionAsc {
							s.OrderBy(sql.Asc(c))
						} else if orderBy.Direction == OrderDirectionDesc {
							s.OrderBy(sql.Desc(c))
						}
					}
				}).
				All(ctx)
		}
		{{- end }}
	{{ end }}
{{ end }}

{{ end }}
